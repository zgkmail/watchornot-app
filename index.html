<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CineSense - Snap & Rate Movies</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Theme Color -->
    <meta name="theme-color" content="#000000">

    <!-- iOS Specific Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="CineSense">

    <!-- App Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152.png">
    <link rel="apple-touch-icon" sizes="120x120" href="icons/icon-120.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
            -webkit-tap-highlight-color: transparent;
        }

        #root {
            width: 100%;
            height: 100%;
        }

        /* Prevent pull-to-refresh on mobile */
        body {
            overscroll-behavior: none;
        }

        /* Safe area support for iOS notch and home indicator */
        .safe-area-top {
            padding-top: max(env(safe-area-inset-top), 20px);
        }

        .safe-area-bottom {
            padding-bottom: max(env(safe-area-inset-bottom), 20px);
        }

        .safe-area-left {
            padding-left: env(safe-area-inset-left);
        }

        .safe-area-right {
            padding-right: env(safe-area-inset-right);
        }

        /* Hide scrollbars but allow scrolling */
        ::-webkit-scrollbar {
            display: none;
        }

        * {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Prevent text selection on mobile for better native feel */
        @media (max-width: 768px) {
            * {
                -webkit-user-select: none;
                user-select: none;
                -webkit-touch-callout: none;
            }

            input, textarea {
                -webkit-user-select: text;
                user-select: text;
            }
        }

        /* Ensure full viewport height accounting for dynamic Safari UI */
        @supports (-webkit-touch-callout: none) {
            #root {
                height: -webkit-fill-available;
            }

            body {
                height: -webkit-fill-available;
            }
        }

        /* Use dynamic viewport height for mobile browsers */
        @supports (height: 100dvh) {
            body {
                height: 100dvh;
            }

            #root {
                height: 100dvh;
            }

            .app-container {
                height: 100dvh !important;
                max-height: 100dvh !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef } = React;

        // SVG Icon Components
        const Camera = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                <circle cx="12" cy="13" r="4"></circle>
            </svg>
        );

        const Clock = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
        );

        const User = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
            </svg>
        );

        const ThumbsUp = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
            </svg>
        );

        const ThumbsDown = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
            </svg>
        );

        const Upload = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );

        const Search = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
            </svg>
        );

        const X = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        const ChevronRight = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        );

        const Palette = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="13.5" cy="6.5" r=".5"></circle>
                <circle cx="17.5" cy="10.5" r=".5"></circle>
                <circle cx="8.5" cy="7.5" r=".5"></circle>
                <circle cx="6.5" cy="12.5" r=".5"></circle>
                <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"></path>
            </svg>
        );

        const Trash2 = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        );

        const Hash = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="4" y1="9" x2="20" y2="9"></line>
                <line x1="4" y1="15" x2="20" y2="15"></line>
                <line x1="10" y1="3" x2="8" y2="21"></line>
                <line x1="16" y1="3" x2="14" y2="21"></line>
            </svg>
        );

        const Moon = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
        );

        const HelpCircle = ({ className }) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
        );

        const CineSenseApp = () => {
            const [activeTab, setActiveTab] = useState('snap');
            const [hasScanned, setHasScanned] = useState(false);
            const [isProcessing, setIsProcessing] = useState(false);
            const [currentMovie, setCurrentMovie] = useState(null);
            const [currentMovieRating, setCurrentMovieRating] = useState(null);
            const [movieHistory, setMovieHistory] = useState({});
            const [searchQuery, setSearchQuery] = useState('');
            const [searchMode, setSearchMode] = useState(false);
            const fileInputRef = useRef(null);
            const cameraInputRef = useRef(null);
            const videoRef = useRef(null);
            const [stream, setStream] = useState(null);
            const [cameraActive, setCameraActive] = useState(false);

            // Swipe-to-delete state
            const [swipedItem, setSwipedItem] = useState(null);
            const [swipeOffset, setSwipeOffset] = useState(0);
            const [touchStart, setTouchStart] = useState(null);

            // Backend API configuration
            const BACKEND_URL = 'http://10.0.0.101:3001';

            // Load movie history from backend on mount
            React.useEffect(() => {
                const loadMovieHistory = async () => {
                    try {
                        const response = await fetch(`${BACKEND_URL}/api/ratings`, {
                            credentials: 'include'
                        });

                        if (response.ok) {
                            const data = await response.json();
                            // Convert array to object keyed by movie_id for compatibility
                            const historyObj = {};
                            data.ratings.forEach(movie => {
                                historyObj[movie.movie_id] = {
                                    id: movie.movie_id,
                                    title: movie.title,
                                    year: movie.year,
                                    genre: movie.genre,
                                    cast: movie.cast,
                                    poster: movie.poster,
                                    imdbRating: movie.imdb_rating,
                                    rottenTomatoes: movie.rotten_tomatoes,
                                    metacritic: movie.metacritic,
                                    rating: movie.rating,
                                    timestamp: movie.timestamp,
                                    personalScore: movie.personalScore
                                };
                            });
                            setMovieHistory(historyObj);
                            console.log('âœ… Loaded', data.ratings.length, 'movies from backend');
                        } else {
                            console.warn('Failed to load movie history from backend');
                        }
                    } catch (error) {
                        console.error('Error loading movie history:', error);
                    }
                };

                loadMovieHistory();
            }, []);

            const ratedMovies = Object.values(movieHistory).filter(movie => movie.rating !== null);
            const ratedCount = ratedMovies.length;
            const totalNeeded = 5;
            const remainingNeeded = totalNeeded - ratedCount;
            const progressPercentage = (ratedCount / totalNeeded) * 100;

            const handleMovieRating = async (movieId, rating) => {
                const movie = movieHistory[movieId];
                if (!movie) return;

                // Toggle rating if same, otherwise set new rating
                const newRating = movie.rating === rating ? null : rating;

                // Optimistically update UI
                setMovieHistory(prev => ({
                    ...prev,
                    [movieId]: {
                        ...movie,
                        rating: newRating
                    }
                }));

                // Save to backend
                try {
                    const response = await fetch(`${BACKEND_URL}/api/ratings`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            id: movie.id,
                            title: movie.title,
                            genre: movie.genre,
                            year: movie.year,
                            imdbRating: movie.imdbRating,
                            rottenTomatoes: movie.rottenTomatoes,
                            metacritic: movie.metacritic,
                            poster: movie.poster,
                            cast: movie.cast,
                            rating: newRating,
                            timestamp: movie.timestamp
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        // Update with personal score from backend
                        setMovieHistory(prev => ({
                            ...prev,
                            [movieId]: {
                                ...prev[movieId],
                                personalScore: data.personalScore
                            }
                        }));

                        // Also update currentMovie if it's the same movie
                        if (currentMovie && currentMovie.id === movieId) {
                            setCurrentMovie(prev => ({
                                ...prev,
                                rating: newRating,
                                personalScore: data.personalScore
                            }));
                        }

                        console.log('âœ… Rating saved, personal score:', data.personalScore);
                    } else {
                        console.error('Failed to save rating');
                    }
                } catch (error) {
                    console.error('Error saving rating:', error);
                }
            };

            // Swipe-to-delete handlers
            const handleTouchStart = (e, movieId) => {
                // If touching a different item, reset swipe state
                if (swipedItem && swipedItem !== movieId) {
                    setSwipeOffset(0);
                }
                setTouchStart(e.touches[0].clientX);
                setSwipedItem(movieId);
            };

            const handleTouchMove = (e, movieId) => {
                if (!touchStart || swipedItem !== movieId) return;

                const currentTouch = e.touches[0].clientX;
                const diff = touchStart - currentTouch;

                // Allow left swipe (positive diff) up to 100px, and right swipe (negative diff) to cancel
                if (diff > 0) {
                    setSwipeOffset(Math.min(diff, 100));
                } else {
                    // Right swipe - snap back to 0
                    setSwipeOffset(0);
                }
            };

            const handleTouchEnd = () => {
                // If swiped more than 50px, keep it revealed
                if (swipeOffset > 50) {
                    setSwipeOffset(100);
                } else {
                    // Otherwise, snap back
                    setSwipeOffset(0);
                    setSwipedItem(null);
                }
                setTouchStart(null);
            };

            const handleDeleteMovie = async (movieId) => {
                // Optimistically update UI
                setMovieHistory(prev => {
                    const newHistory = { ...prev };
                    delete newHistory[movieId];
                    return newHistory;
                });
                setSwipedItem(null);
                setSwipeOffset(0);

                // Delete from backend
                try {
                    await fetch(`${BACKEND_URL}/api/ratings/${movieId}`, {
                        method: 'DELETE',
                        credentials: 'include'
                    });
                    console.log('âœ… Movie deleted from backend');
                } catch (error) {
                    console.error('Error deleting movie from backend:', error);
                }
            };

            const startCamera = async () => {
                try {
                    console.log('ðŸŽ¥ Requesting camera access...');

                    // Check if getUserMedia is available
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('Camera API not available. Your browser may not support camera access.');
                    }

                    const mediaStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });

                    console.log('âœ… Camera access granted');

                    if (videoRef.current) {
                        videoRef.current.srcObject = mediaStream;
                        setStream(mediaStream);
                        setCameraActive(true);
                    }
                } catch (err) {
                    console.error('âŒ Camera error:', err);

                    let errorMessage = 'ðŸ“· Camera Access Issue\n\n';

                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        errorMessage += 'âš ï¸ Camera permission denied\n\n';
                        errorMessage += 'On iOS Safari:\n';
                        errorMessage += 'â€¢ Go to Settings > Safari > Camera\n';
                        errorMessage += 'â€¢ Allow camera access\n';
                        errorMessage += 'â€¢ Or use "Upload Image" instead';
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                        errorMessage += 'âš ï¸ No camera found\n\n';
                        errorMessage += 'Please use "Upload Image" instead';
                    } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                        errorMessage += 'âš ï¸ Camera is being used by another app\n\n';
                        errorMessage += 'Close other apps and try again';
                    } else if (err.name === 'NotSupportedError' || err.message.includes('secure')) {
                        errorMessage += 'âš ï¸ HTTPS Required\n\n';
                        errorMessage += 'Camera access requires HTTPS.\n\n';
                        errorMessage += 'Workaround:\n';
                        errorMessage += '1. Use "Upload Image" instead\n';
                        errorMessage += '2. Take a photo first, then upload it\n';
                        errorMessage += '3. Or use manual search';
                    } else {
                        errorMessage += 'âš ï¸ Error: ' + (err.message || err.name || 'Unknown error') + '\n\n';
                        errorMessage += 'Try using "Upload Image" instead';
                    }

                    alert(errorMessage);
                }
            };

            const stopCamera = () => {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    setStream(null);
                    setCameraActive(false);
                }
            };

            const captureFromCamera = () => {
                if (!videoRef.current) return;
                const canvas = document.createElement('canvas');
                canvas.width = videoRef.current.videoWidth;
                canvas.height = videoRef.current.videoHeight;
                canvas.getContext('2d').drawImage(videoRef.current, 0, 0);
                const imageDataUrl = canvas.toDataURL('image/jpeg');
                stopCamera();
                processImage(imageDataUrl);
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        processImage(e.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            };

            /**
             * Clean and extract movie/show title and year from OCR text
             * Handles streaming interfaces, posters, and title cards
             * Returns: { title: string, year: number|null }
             */
            const cleanMovieTitle = (rawText) => {
                console.log('ðŸ§¹ Cleaning detected text...');
                console.log('Raw text:', rawText);

                if (!rawText || rawText.trim().length === 0) {
                    return null;
                }

                // Split into lines
                const lines = rawText.split('\n').map(line => line.trim()).filter(line => line.length > 0);

                console.log('Lines found:', lines.length);
                console.log('Lines:', lines);

                // Extract year if present (looking for 4-digit years between 1900-2099)
                let extractedYear = null;
                const yearPattern = /\b(19\d{2}|20\d{2})\b/;

                for (const line of lines) {
                    const yearMatch = line.match(yearPattern);
                    if (yearMatch) {
                        extractedYear = parseInt(yearMatch[1]);
                        console.log('ðŸ“… Found year:', extractedYear);
                        break;
                    }
                }

                // Common UI elements and browser noise to remove
                const uiNoise = [
                    'play', 'pause', 'watch', 'trailer', 'resume', 'continue watching',
                    'add to list', 'my list', 'more info', 'details', 'info',
                    'hd', 'uhd', '4k', 'ad', 'cc', 'audio description',
                    'pg-13', 'pg', 'r', 'nr', 'tv-ma', 'tv-14', 'tv-pg', 'tv-y', 'tv-g',
                    'episodes', 'seasons', 'season', 'episode',
                    'download', 'share', 'rate', 'similar titles',
                    // Browser UI
                    'tab', 'tabs', 'window', 'close', 'minimize', 'maximize',
                    'back', 'forward', 'reload', 'home', 'search',
                    // Generic words
                    'baby', 'fish', 'people', 'man', 'woman', 'boy', 'girl'
                ];

                // Filter out lines that look like URLs or file paths
                const isUrlOrPath = (line) => {
                    return line.includes('://') ||
                           line.includes('www.') ||
                           line.includes('.com') ||
                           line.includes('.net') ||
                           line.match(/^[a-z]+\/[a-z]+/) || // path like "user/repo"
                           line.includes('github') ||
                           line.includes('localhost');
                };

                // Clean each line
                const cleanedLines = lines.map(line => {
                    let cleaned = line;

                    // Filter out URLs and paths first
                    if (isUrlOrPath(cleaned)) {
                        return '';
                    }

                    // Remove special characters at the start (like #, @, etc.)
                    cleaned = cleaned.replace(/^[#@$%^&*]+/, '');

                    // Remove common patterns
                    cleaned = cleaned.replace(/^\d+$/, ''); // Pure numbers
                    cleaned = cleaned.replace(/^[+\-Ã—xX]$/, ''); // Single operators including X
                    cleaned = cleaned.replace(/^\d{4}$/, ''); // Years alone
                    cleaned = cleaned.replace(/^\d+h?\s*\d*m?$/, ''); // Runtime (2h 22m)
                    cleaned = cleaned.replace(/^[0-9.,]+$/, ''); // Ratings/numbers

                    // Remove UI noise words
                    const lowerCleaned = cleaned.toLowerCase();
                    if (uiNoise.some(noise => lowerCleaned === noise)) {
                        return '';
                    }

                    // Remove lines that are mostly symbols
                    if (cleaned.replace(/[a-zA-Z0-9]/g, '').length > cleaned.length * 0.5) {
                        return '';
                    }

                    // Remove very short lines (likely UI elements)
                    if (cleaned.length <= 1) {
                        return '';
                    }

                    // Remove single capital letters (like menu items)
                    if (/^[A-Z]$/.test(cleaned)) {
                        return '';
                    }

                    return cleaned.trim();
                }).filter(line => line.length > 0);

                console.log('Cleaned lines:', cleanedLines);

                if (cleanedLines.length === 0) {
                    console.log('âš ï¸  No clean text remaining after filtering');
                    return null;
                }

                // Score each line to find the most title-like one
                const scoreLine = (line) => {
                    let score = 0;

                    // Prefer lines with multiple words
                    const wordCount = line.split(/\s+/).length;
                    if (wordCount >= 2 && wordCount <= 6) score += 30;
                    if (wordCount === 1) score += 10;

                    // Prefer title case (first letter of words capitalized)
                    const words = line.split(/\s+/);
                    const capitalizedWords = words.filter(w => /^[A-Z]/.test(w)).length;
                    score += (capitalizedWords / words.length) * 20;

                    // Penalize all caps (usually UI elements)
                    if (line === line.toUpperCase() && line.length > 3) {
                        score -= 15;
                    }

                    // Prefer reasonable length (5-50 chars)
                    if (line.length >= 5 && line.length <= 50) {
                        score += 20;
                    }

                    // Penalize very short or very long
                    if (line.length < 3) score -= 20;
                    if (line.length > 60) score -= 10;

                    return score;
                };

                // Score and sort candidates
                const scoredLines = cleanedLines.map(line => ({
                    line,
                    score: scoreLine(line)
                })).sort((a, b) => b.score - a.score);

                console.log('Scored candidates:');
                scoredLines.slice(0, 5).forEach((item, i) => {
                    console.log(`  ${i+1}. "${item.line}" (score: ${item.score})`);
                });

                // Pick the best candidate
                let title = scoredLines[0].line;

                // Final cleanup
                title = title
                    .replace(/[#@$%^&*_+=|\\<>]/g, '') // Remove special chars
                    .replace(/\s+/g, ' ') // Normalize spaces
                    .trim();

                console.log('âœ¨ Extracted title:', title);
                if (extractedYear) {
                    console.log('âœ¨ Extracted year:', extractedYear);
                }

                return { title: title || null, year: extractedYear };
            };

            /**
             * Extract movie title candidates from multiple detection sources
             * Prioritizes web detection, then falls back to OCR text
             */
            const extractMovieCandidates = (webDetection, textAnnotations, logoAnnotations) => {
                console.log('\nðŸŽ¬ Extracting movie candidates...');

                const candidates = [];
                const seenTitles = new Set();

                // Streaming services to filter out
                const streamingServices = new Set([
                    'netflix', 'prime video', 'amazon prime', 'disney+', 'disney plus', 'hulu',
                    'hbo max', 'paramount+', 'peacock', 'apple tv+', 'youtube', 'tubi'
                ]);

                // 1. WEB DETECTION - Most reliable source
                if (webDetection?.webEntities) {
                    console.log('ðŸ“Š Processing web entities...');
                    webDetection.webEntities.forEach(entity => {
                        if (!entity.description) return;

                        const title = entity.description.trim();
                        const lowerTitle = title.toLowerCase();

                        // Filter out streaming services and very short titles
                        if (streamingServices.has(lowerTitle) || title.length < 2) return;

                        // Filter out generic terms
                        if (['film', 'movie', 'series', 'tv show', 'watch', 'play', 'episode'].includes(lowerTitle)) return;

                        const titleKey = lowerTitle.replace(/[^\w]/g, '');
                        if (seenTitles.has(titleKey)) return;
                        seenTitles.add(titleKey);

                        candidates.push({
                            title: title,
                            confidence: Math.min(entity.score || 0.7, 0.95),
                            source: 'web_entity'
                        });
                    });
                }

                // 2. BEST GUESS LABELS - High confidence
                if (webDetection?.bestGuessLabels) {
                    console.log('ðŸŽ¯ Processing best guess labels...');
                    webDetection.bestGuessLabels.forEach(label => {
                        if (!label.label) return;

                        const title = label.label.trim();
                        const lowerTitle = title.toLowerCase();

                        if (streamingServices.has(lowerTitle) || title.length < 2) return;

                        const titleKey = lowerTitle.replace(/[^\w]/g, '');
                        if (seenTitles.has(titleKey)) return;
                        seenTitles.add(titleKey);

                        candidates.push({
                            title: title,
                            confidence: 0.9,
                            source: 'best_guess'
                        });
                    });
                }

                // 3. OCR TEXT - Fallback (extract multiple candidates from OCR)
                if (textAnnotations.length > 0 && candidates.length < 3) {
                    console.log('ðŸ“ Processing OCR text as fallback...');
                    const detectedText = textAnnotations[0]?.description || '';
                    if (detectedText) {
                        const cleanedData = cleanMovieTitle(detectedText);
                        if (cleanedData?.title) {
                            const titleKey = cleanedData.title.toLowerCase().replace(/[^\w]/g, '');
                            if (!seenTitles.has(titleKey)) {
                                seenTitles.add(titleKey);
                                candidates.push({
                                    title: cleanedData.title,
                                    year: cleanedData.year,
                                    confidence: 0.6,
                                    source: 'ocr_text'
                                });
                            }
                        }

                        // Also try extracting title-like phrases directly from the text
                        const lines = detectedText.split('\n').map(l => l.trim()).filter(l => l.length > 0);
                        for (const line of lines) {
                            // Look for title case phrases (3-50 chars, multiple capitalized words)
                            if (line.length >= 3 && line.length <= 50) {
                                const words = line.split(/\s+/);
                                const capitalizedCount = words.filter(w => /^[A-Z]/.test(w)).length;

                                // If most words are capitalized (title case), it might be a title
                                if (words.length >= 2 && capitalizedCount >= words.length * 0.6) {
                                    const titleKey = line.toLowerCase().replace(/[^\w]/g, '');
                                    if (!seenTitles.has(titleKey) && candidates.length < 5) {
                                        seenTitles.add(titleKey);
                                        candidates.push({
                                            title: line.trim(),
                                            confidence: 0.5,
                                            source: 'ocr_phrase'
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                // Sort by confidence (highest first)
                candidates.sort((a, b) => b.confidence - a.confidence);

                return candidates.slice(0, 5); // Return top 5 candidates
            };

            /**
             * Search for movie using multiple candidates in order of confidence
             */
            const searchMovieWithCandidates = async (candidates) => {
                for (let i = 0; i < candidates.length; i++) {
                    const candidate = candidates[i];
                    console.log(`\nðŸ” Trying candidate ${i+1}/${candidates.length}: "${candidate.title}"`);

                    try {
                        const result = await searchMovie(candidate.title, candidate.year, true);

                        // If we found a result, we're done
                        if (result) {
                            console.log('âœ… Found match!');
                            return result;
                        }

                        // If confidence is low and no result, try next
                        if (candidate.confidence < 0.7) {
                            console.log('âš ï¸  Low confidence, trying next candidate...');
                            continue;
                        }
                    } catch (error) {
                        console.error('âŒ Error searching for candidate:', error);
                        // Continue to next candidate
                    }
                }

                // If we get here, nothing worked
                alert('Could not find a matching movie or TV show.\n\nDetected text doesn\'t match any titles.\nTry:\nâ€¢ Taking another photo with better angle\nâ€¢ Uploading a clearer image\nâ€¢ Using manual search');
                setIsProcessing(false);
                setSearchMode(true);
            };

            /**
             * Compress image to stay under Claude API's 5 MB limit
             * Reduces dimensions and adjusts quality while maintaining readability
             */
            const compressImage = async (imageDataUrl) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Calculate new dimensions to keep under ~4 MB (buffer for 5 MB limit)
                        // Base64 is ~1.37x larger than binary, so target ~3 MB binary = ~4 MB base64
                        const MAX_SIZE_MB = 4;
                        const MAX_SIZE_BYTES = MAX_SIZE_MB * 1024 * 1024;

                        let width = img.width;
                        let height = img.height;
                        let quality = 0.85;

                        // Start with a reasonable max dimension
                        const MAX_DIMENSION = 1920;
                        if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                            if (width > height) {
                                height = Math.round((height * MAX_DIMENSION) / width);
                                width = MAX_DIMENSION;
                            } else {
                                width = Math.round((width * MAX_DIMENSION) / height);
                                height = MAX_DIMENSION;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        // Try to compress until under size limit
                        let compressed = canvas.toDataURL('image/jpeg', quality);
                        let attempts = 0;

                        while (compressed.length > MAX_SIZE_BYTES && attempts < 5) {
                            quality -= 0.1;
                            if (quality < 0.5) {
                                // Reduce dimensions further
                                width = Math.round(width * 0.8);
                                height = Math.round(height * 0.8);
                                canvas.width = width;
                                canvas.height = height;
                                ctx.drawImage(img, 0, 0, width, height);
                                quality = 0.85;
                            }
                            compressed = canvas.toDataURL('image/jpeg', quality);
                            attempts++;
                        }

                        console.log('ðŸ—œï¸  Image compressed:');
                        console.log('   Original:', imageDataUrl.length, 'bytes');
                        console.log('   Compressed:', compressed.length, 'bytes');
                        console.log('   Dimensions:', width, 'x', height);
                        console.log('   Quality:', quality);
                        console.log('   Reduction:', ((1 - compressed.length / imageDataUrl.length) * 100).toFixed(1) + '%');

                        resolve(compressed);
                    };
                    img.onerror = () => reject(new Error('Failed to load image for compression'));
                    img.src = imageDataUrl;
                });
            };

            const processImage = async (imageData) => {
                setIsProcessing(true);
                console.log('\n========== FRONTEND IMAGE PROCESSING ==========');
                console.log('Timestamp:', new Date().toISOString());

                try {
                    // Validate image data
                    if (!imageData) {
                        throw new Error('No image data provided');
                    }

                    console.log('âœ“ Image data received');
                    console.log('Data URL length:', imageData.length);
                    console.log('Data URL prefix:', imageData.substring(0, 50));

                    // Compress image to stay under Claude API's 5 MB limit
                    const compressedImage = await compressImage(imageData);

                    // Extract base64 portion
                    const base64Image = compressedImage.split(',')[1];

                    if (!base64Image) {
                        throw new Error('Failed to extract base64 data from image');
                    }

                    console.log('âœ“ Base64 extracted, length:', base64Image.length, 'characters');
                    console.log('ðŸ“¤ Sending request to Claude API...');
                    console.log('Backend URL:', `${BACKEND_URL}/api/claude/identify`);

                    const requestStart = Date.now();
                    const claudeResponse = await fetch(`${BACKEND_URL}/api/claude/identify`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ image: base64Image })
                    });

                    const requestDuration = Date.now() - requestStart;
                    console.log('ðŸ“¥ Response received in', requestDuration, 'ms');
                    console.log('Response status:', claudeResponse.status);
                    console.log('Response OK:', claudeResponse.ok);

                    if (!claudeResponse.ok) {
                        const errorData = await claudeResponse.json();
                        console.error('âŒ Backend error response:', errorData);

                        let errorMsg = errorData.error || 'Claude API error';
                        if (errorData.debug) {
                            console.error('Debug info:', errorData.debug);
                            errorMsg += '\n\nDebug: ' + JSON.stringify(errorData.debug, null, 2);
                        }

                        throw new Error(errorMsg);
                    }

                    const claudeData = await claudeResponse.json();
                    console.log('âœ… Claude API response received');
                    console.log('Response data:', claudeData);

                    const detectedTitle = claudeData.title;
                    const detectedYear = claudeData.year;
                    const confidence = claudeData.confidence || 0.9;

                    console.log('\nðŸŽ¯ Claude identified:');
                    console.log('   Title:', detectedTitle);
                    if (detectedYear) {
                        console.log('   Year:', detectedYear);
                    }
                    console.log('   Confidence:', (confidence * 100).toFixed(1) + '%');

                    if (!detectedTitle) {
                        alert('Could not identify a movie or TV show in the image.\n\nTips:\nâ€¢ Point camera at the title screen\nâ€¢ Ensure the title is clearly visible\nâ€¢ Try manual search instead');
                        setIsProcessing(false);
                        setSearchMode(true);
                        return;
                    }

                    // Search for the movie directly with Claude's identified title and year
                    console.log('\nðŸ” Searching TMDB for:', detectedTitle + (detectedYear ? ' (' + detectedYear + ')' : ''));
                    await searchMovie(detectedTitle, detectedYear);
                } catch (error) {
                    console.error('\nâŒâŒâŒ FRONTEND ERROR âŒâŒâŒ');
                    console.error('Error type:', error.constructor.name);
                    console.error('Error message:', error.message);
                    console.error('Error stack:', error.stack);
                    console.error('===============================================\n');

                    // Create user-friendly error message
                    let userMessage = 'Error processing image:\n\n';

                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        userMessage += 'âŒ Cannot connect to backend server\n';
                        userMessage += 'â€¢ Is the backend running on ' + BACKEND_URL + '?\n';
                        userMessage += 'â€¢ Check browser console for details\n';
                    } else if (error.message.includes('API key')) {
                        userMessage += 'âŒ API key issue\n';
                        userMessage += 'â€¢ Vision API key may be invalid or missing\n';
                        userMessage += 'â€¢ Check backend .env file\n';
                    } else if (error.message.includes('403')) {
                        userMessage += 'âŒ API authentication failed\n';
                        userMessage += 'â€¢ Vision API key lacks permissions\n';
                        userMessage += 'â€¢ Ensure Vision API is enabled in Google Cloud Console\n';
                    } else {
                        userMessage += error.message;
                    }

                    userMessage += '\n\nTry manual search instead.';

                    alert(userMessage);
                    setIsProcessing(false);
                    setSearchMode(true);
                }
            };

            const searchMovie = async (query, year = null, silent = false) => {
                console.log('ðŸŽ¬ Starting movie search with query:', query);
                if (year) {
                    console.log('ðŸ“… Using year for filtering/ranking:', year);
                }

                // Generate alternative search queries as fallbacks
                const generateAlternatives = (originalQuery) => {
                    const alternatives = [originalQuery];

                    // Try with "The" prepended (common for movies)
                    if (!originalQuery.toLowerCase().startsWith('the ')) {
                        alternatives.push('The ' + originalQuery);
                    }

                    // Try without "The" if it starts with it
                    if (originalQuery.toLowerCase().startsWith('the ')) {
                        alternatives.push(originalQuery.substring(4));
                    }

                    // Try with "A" prepended
                    if (!originalQuery.toLowerCase().startsWith('a ')) {
                        alternatives.push('A ' + originalQuery);
                    }

                    console.log('ðŸ“‹ Search alternatives:', alternatives);
                    return alternatives;
                };

                // Rank/score a result based on title match, year match, and popularity
                const scoreResult = (result, targetYear, searchQuery) => {
                    let score = 0;

                    const resultTitle = (result.title || result.name || '').toLowerCase();
                    const queryLower = searchQuery.toLowerCase();

                    // Title match scoring (highest priority)
                    if (resultTitle === queryLower) {
                        score += 10000; // Exact title match
                        console.log('      ðŸŽ¯ EXACT TITLE MATCH!');
                    } else if (resultTitle.startsWith(queryLower) || resultTitle.endsWith(queryLower)) {
                        score += 5000; // Title starts or ends with query
                        console.log('      âœ“ Strong title match (prefix/suffix)');
                    } else if (resultTitle.includes(queryLower)) {
                        score += 1000; // Title contains query
                        console.log('      ~ Partial title match (substring)');
                    } else {
                        console.log('      âš ï¸  Weak title match');
                    }

                    // Extract year from result
                    const releaseDate = result.release_date || result.first_air_date;
                    const resultYear = releaseDate ? parseInt(releaseDate.split('-')[0]) : null;

                    // Year match scoring (high priority)
                    if (targetYear && resultYear) {
                        const yearDiff = Math.abs(resultYear - targetYear);
                        if (yearDiff === 0) {
                            score += 1000; // Exact year match
                            console.log('      ðŸŽ¯ Exact year match!', resultYear);
                        } else if (yearDiff === 1) {
                            score += 500; // Off by 1 year (common for international releases)
                            console.log('      ðŸ“… Year close match:', resultYear, '(target:', targetYear + ')');
                        } else {
                            console.log('      âš ï¸  Year mismatch:', resultYear, '(target:', targetYear + ')');
                        }
                    }

                    // Popularity as tertiary factor (normalize to 0-100 scale)
                    const popularityScore = Math.min(result.popularity || 0, 100);
                    score += popularityScore;

                    console.log('      Total Score:', score, '(popularity:', result.popularity?.toFixed(1) + ')');
                    return score;
                };

                const trySearch = async (searchQuery, targetYear) => {
                    console.log('  ðŸ”Ž Trying:', searchQuery);

                    const response = await fetch(
                        `${BACKEND_URL}/api/tmdb/search?query=${encodeURIComponent(searchQuery)}`,
                        { credentials: 'include' }
                    );

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'TMDB search error');
                    }

                    const data = await response.json();

                    // Filter results to only include movies and TV shows (exclude people, etc.)
                    if (data.results && data.results.length > 0) {
                        const validResults = data.results.filter(result =>
                            result.media_type === 'movie' || result.media_type === 'tv'
                        );

                        if (validResults.length > 0) {
                            console.log('    âœ“ Found', validResults.length, 'movie/TV results (filtered from', data.results.length, 'total)');

                            // Rank results
                            const scoredResults = validResults.map(result => ({
                                ...result,
                                _score: scoreResult(result, targetYear, searchQuery)
                            }));

                            // Sort by score (highest first)
                            scoredResults.sort((a, b) => b._score - a._score);

                            // Log top 3 results for debugging
                            console.log('    ðŸ“Š Top results:');
                            scoredResults.slice(0, 3).forEach((result, idx) => {
                                console.log(`      ${idx + 1}. "${result.title || result.name}" (${result.media_type}, ${(result.release_date || result.first_air_date)?.split('-')[0]}) - Score: ${result._score}`);
                            });

                            const best = scoredResults[0];
                            console.log('    ðŸ† Selected:', best.title || best.name, '(' + best.media_type + ', ' + (best.release_date || best.first_air_date)?.split('-')[0] + ')');

                            return best;
                        } else {
                            console.log('    âœ— No movie/TV results (found', data.results.length, 'other results)');
                            return null;
                        }
                    }

                    return null;
                };

                try {
                    const alternatives = generateAlternatives(query);
                    let movie = null;
                    let successfulQuery = null;

                    // Try each alternative until we find a match
                    for (const altQuery of alternatives) {
                        movie = await trySearch(altQuery, year);
                        if (movie) {
                            successfulQuery = altQuery;
                            console.log('âœ… Found match with:', successfulQuery);
                            break;
                        }
                    }

                    if (!movie) {
                        console.log('âŒ No results found with any search strategy');
                        if (silent) {
                            return false;
                        }
                        alert('No results found. Please try:\n\nâ€¢ Manual search with the exact title\nâ€¢ Check if the title was detected correctly in the console');
                        setIsProcessing(false);
                        setSearchMode(true);
                        return;
                    }

                    // Validate media type
                    if (movie.media_type !== 'movie' && movie.media_type !== 'tv') {
                        console.error('âŒ Invalid media type:', movie.media_type);
                        throw new Error('Invalid media type: ' + movie.media_type + '. Expected "movie" or "tv".');
                    }

                    console.log('ðŸ“¦ Fetching details for:', movie.title || movie.name);

                    // Fetch movie details
                    const detailsResponse = await fetch(
                        `${BACKEND_URL}/api/tmdb/${movie.media_type}/${movie.id}`,
                        { credentials: 'include' }
                    );

                    if (!detailsResponse.ok) {
                        const errorData = await detailsResponse.json();
                        throw new Error(errorData.error || 'TMDB details error');
                    }

                    const details = await detailsResponse.json();

                    // Try to fetch OMDb ratings if IMDb ID is available
                    let omdbRatings = null;
                    const imdbId = details.external_ids?.imdb_id;

                    if (imdbId) {
                        console.log('ðŸ“Š Fetching additional ratings from OMDb...');
                        console.log('   IMDb ID:', imdbId);

                        try {
                            const omdbResponse = await fetch(
                                `${BACKEND_URL}/api/omdb/ratings/${imdbId}`,
                                { credentials: 'include' }
                            );

                            if (omdbResponse.ok) {
                                const omdbData = await omdbResponse.json();
                                if (omdbData.found) {
                                    omdbRatings = omdbData.ratings;
                                    console.log('âœ… OMDb ratings fetched:');
                                    console.log('   IMDb:', omdbRatings.imdb.rating);
                                    console.log('   Rotten Tomatoes:', omdbRatings.rottenTomatoes);
                                    console.log('   Metacritic:', omdbRatings.metacritic);
                                } else {
                                    console.log('âš ï¸  Movie not found in OMDb');
                                }
                            } else {
                                console.warn('âš ï¸  OMDb API request failed:', omdbResponse.status);
                            }
                        } catch (omdbError) {
                            console.warn('âš ï¸  Could not fetch OMDb ratings:', omdbError.message);
                        }
                    } else {
                        console.log('âš ï¸  No IMDb ID available, skipping OMDb ratings');
                    }

                    const movieData = {
                        id: movie.id,
                        title: movie.title || movie.name,
                        year: (movie.release_date || movie.first_air_date || '').split('-')[0],
                        genre: details.genres?.[0]?.name || 'Drama',
                        cast: details.credits?.cast?.slice(0, 3).map(c => c.name).join(', ') || 'N/A',
                        poster: movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : null,
                        score: movie.vote_average,
                        imdbRating: omdbRatings?.imdb?.rating || null,
                        imdbVotes: omdbRatings?.imdb?.votes || null,
                        rottenTomatoes: omdbRatings?.rottenTomatoes || null,
                        metacritic: omdbRatings?.metacritic || null,
                        rating: null,
                        timestamp: new Date().toISOString()
                    };

                    console.log('ðŸŽ‰ Successfully found movie:', movieData.title);

                    // Calculate personal score from backend
                    try {
                        const scoreResponse = await fetch(`${BACKEND_URL}/api/ratings/calculate-score`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify(movieData)
                        });

                        if (scoreResponse.ok) {
                            const scoreData = await scoreResponse.json();
                            movieData.personalScore = scoreData.personalScore;
                            console.log('ðŸŽ¯ Personal score:', scoreData.personalScore);
                        }
                    } catch (error) {
                        console.warn('Could not calculate personal score:', error);
                    }

                    setCurrentMovie(movieData);

                    // Add to history immediately when identified
                    setMovieHistory(prev => ({
                        ...prev,
                        [movie.id]: prev[movie.id] ? { ...prev[movie.id], ...movieData, rating: prev[movie.id].rating } : movieData
                    }));

                    // Save to backend (without rating initially)
                    try {
                        await fetch(`${BACKEND_URL}/api/ratings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify(movieData)
                        });
                    } catch (error) {
                        console.warn('Could not save movie to backend:', error);
                    }

                    setHasScanned(true);
                    setIsProcessing(false);
                    setSearchMode(false);

                    if (silent) {
                        return true;
                    }
                } catch (error) {
                    console.error('Movie search error:', error);
                    if (silent) {
                        return false;
                    }
                    alert('Search error: ' + error.message + '. Please check your TMDB API key.');
                    setIsProcessing(false);
                }
            };

            const handleRating = (rating) => {
                if (!currentMovie) return;
                setCurrentMovieRating(rating);
                handleMovieRating(currentMovie.id, rating);
                setTimeout(() => {
                    setHasScanned(false);
                    setCurrentMovieRating(null);
                    setCurrentMovie(null);
                }, 1000);
            };

            const handleNotNow = () => {
                setHasScanned(false);
                setCurrentMovieRating(null);
                setCurrentMovie(null);
            };

            return (
                <div className="flex items-center justify-center min-h-screen bg-gray-900 md:p-4">
                    <div className="app-container relative w-full bg-black overflow-hidden md:max-w-sm md:rounded-[3rem] md:shadow-2xl" style={{ height: '100vh', maxHeight: '100vh' }}>
                        {/* Notch - only show on desktop mockup */}
                        <div className="absolute top-0 left-1/2 transform -translate-x-1/2 w-40 h-7 bg-black rounded-b-3xl z-50 hidden md:block"></div>

                        <div className="relative h-full flex flex-col bg-black safe-area-top safe-area-left safe-area-right">
                            <div className="flex-1 relative overflow-hidden">
                                
                                {activeTab === 'history' && (
                                    <div className="h-full overflow-y-auto bg-black">
                                        <div className="px-6 pt-12 pb-4">
                                            <h1 className="text-white text-3xl font-bold text-center">My Snap History</h1>
                                        </div>
                                        <div className="px-6 pb-6">
                                            <p className="text-white text-center mb-3 font-semibold">Taste Profile {ratedCount}/{totalNeeded} Complete</p>
                                            <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
                                                <div className="h-full bg-green-500 rounded-full transition-all duration-300" style={{ width: progressPercentage + '%' }}></div>
                                            </div>
                                            <p className="text-gray-300 text-center mt-3 text-sm">
                                                {remainingNeeded > 0 
                                                    ? `Rate ${remainingNeeded} more ${remainingNeeded === 1 ? 'movie/TV show' : 'movies/TV shows'} to unlock recommendations!`
                                                    : 'You unlocked personalized recommendations!'
                                                }
                                            </p>
                                        </div>
                                        <div className="px-4 pb-24">
                                            {Object.keys(movieHistory).length === 0 ? (
                                                <div className="text-center text-gray-400 py-12">
                                                    <Clock className="w-16 h-16 mx-auto mb-4 opacity-50" />
                                                    <p>No titles yet. Start snapping!</p>
                                                </div>
                                            ) : (
                                                <div className="space-y-3">
                                                    {Object.values(movieHistory).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).map((movie) => (
                                                        <div key={movie.id} className="relative overflow-hidden rounded-xl">
                                                            {/* Delete button background */}
                                                            <div className="absolute right-0 top-0 bottom-0 w-24 bg-red-600 flex items-center justify-center rounded-xl">
                                                                <Trash2 className="w-6 h-6 text-white" />
                                                            </div>

                                                            {/* Movie card */}
                                                            <div
                                                                className="bg-gray-800 rounded-xl p-3 flex gap-3 relative"
                                                                style={{
                                                                    transform: swipedItem === movie.id ? `translateX(-${swipeOffset}px)` : 'translateX(0)',
                                                                    transition: touchStart ? 'none' : 'transform 0.3s ease'
                                                                }}
                                                                onTouchStart={(e) => handleTouchStart(e, movie.id)}
                                                                onTouchMove={(e) => handleTouchMove(e, movie.id)}
                                                                onTouchEnd={handleTouchEnd}
                                                            >
                                                                {movie.poster ? (
                                                                    <img
                                                                        src={movie.poster}
                                                                        alt={movie.title}
                                                                        className="w-24 h-36 rounded-lg flex-shrink-0 object-cover"
                                                                    />
                                                                ) : (
                                                                    <div className="w-24 h-36 bg-gradient-to-br from-gray-700 to-gray-900 rounded-lg flex-shrink-0"></div>
                                                                )}
                                                                <div className="flex-1 flex flex-col justify-between">
                                                                    <div>
                                                                        <h3 className="text-white font-bold text-lg mb-1 line-clamp-2">{movie.title}</h3>
                                                                        <p className="text-gray-400 text-sm mb-1">{movie.year} â€¢ {movie.genre}</p>
                                                                        <div className="flex items-center gap-3 text-sm">
                                                                            {movie.personalScore && (
                                                                                <div className="flex items-center gap-1 text-purple-400">
                                                                                    <span>ðŸŽ¯</span>
                                                                                    <span className="font-semibold">{movie.personalScore}/10</span>
                                                                                </div>
                                                                            )}
                                                                            {movie.imdbRating && (
                                                                                <div className="flex items-center gap-1 text-yellow-400">
                                                                                    <span>â­</span>
                                                                                    <span className="font-semibold">{movie.imdbRating}/10</span>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </div>
                                                                    <div className="flex gap-2">
                                                                        <button
                                                                            onClick={() => handleMovieRating(movie.id, 'up')}
                                                                            className={'w-10 h-10 rounded-lg flex items-center justify-center ' + (movie.rating === 'up' ? 'bg-green-500' : 'bg-gray-600')}
                                                                        >
                                                                            <ThumbsUp className="w-5 h-5 text-white" />
                                                                        </button>
                                                                        <button
                                                                            onClick={() => handleMovieRating(movie.id, 'down')}
                                                                            className={'w-10 h-10 rounded-lg flex items-center justify-center ' + (movie.rating === 'down' ? 'bg-red-500' : 'bg-gray-600')}
                                                                        >
                                                                            <ThumbsDown className="w-5 h-5 text-white" />
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                            </div>

                                                            {/* Delete button overlay (clickable when swiped) */}
                                                            {swipedItem === movie.id && swipeOffset >= 50 && (
                                                                <div
                                                                    className="absolute right-0 top-0 bottom-0 w-24 flex items-center justify-center cursor-pointer"
                                                                    onClick={() => handleDeleteMovie(movie.id)}
                                                                >
                                                                    <Trash2 className="w-6 h-6 text-white" />
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}

                                {activeTab === 'snap' && !hasScanned && (
                                    <div className="h-full relative">
                                        {cameraActive ? (
                                            <div className="h-full relative">
                                                <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover" />
                                                <div className="absolute bottom-32 left-1/2 transform -translate-x-1/2 flex gap-4">
                                                    <button onClick={captureFromCamera} className="w-20 h-20 rounded-full bg-white shadow-lg" />
                                                    <button onClick={stopCamera} className="w-20 h-20 rounded-full bg-red-500 shadow-lg flex items-center justify-center">
                                                        <X className="w-8 h-8 text-white" />
                                                    </button>
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="h-full flex flex-col items-center justify-center px-8 bg-gradient-to-b from-gray-900 to-black">
                                                <Camera className="w-20 h-20 text-gray-400 mb-6" />
                                                <p className="text-white text-lg font-light text-center mb-8">Snap a movie or TV show title screen</p>
                                                <button onClick={() => cameraInputRef.current?.click()} className="w-full bg-blue-600 hover:bg-blue-700 text-white py-4 px-6 rounded-xl mb-4 flex items-center justify-center gap-2">
                                                    <Camera className="w-5 h-5" />
                                                    Take Photo
                                                </button>
                                                <button onClick={() => fileInputRef.current?.click()} className="w-full bg-gray-700 hover:bg-gray-600 text-white py-4 px-6 rounded-xl mb-4 flex items-center justify-center gap-2">
                                                    <Upload className="w-5 h-5" />
                                                    Upload Image
                                                </button>
                                                <input ref={cameraInputRef} type="file" accept="image/*" capture="environment" onChange={handleFileUpload} className="hidden" />
                                                <input ref={fileInputRef} type="file" accept="image/*" onChange={handleFileUpload} className="hidden" />
                                                <button onClick={() => setSearchMode(!searchMode)} className="w-full bg-gray-800 hover:bg-gray-700 text-white py-4 px-6 rounded-xl flex items-center justify-center gap-2">
                                                    <Search className="w-5 h-5" />
                                                    Manual Search
                                                </button>
                                                {searchMode && (
                                                    <div className="w-full mt-4">
                                                        <input 
                                                            type="text" 
                                                            value={searchQuery} 
                                                            onChange={(e) => setSearchQuery(e.target.value)} 
                                                            onKeyPress={(e) => e.key === 'Enter' && searchQuery.trim() && (setIsProcessing(true), searchMovie(searchQuery))} 
                                                            placeholder="Enter movie or TV show name..." 
                                                            className="w-full bg-gray-700 text-white py-3 px-4 rounded-xl mb-2" 
                                                        />
                                                        <button onClick={() => searchQuery.trim() && (setIsProcessing(true), searchMovie(searchQuery))} className="w-full bg-green-600 hover:bg-green-700 text-white py-3 px-6 rounded-xl">
                                                            Search
                                                        </button>
                                                    </div>
                                                )}
                                                {isProcessing && (
                                                    <div className="mt-6 text-center">
                                                        <div className="animate-spin rounded-full h-12 w-12 border-4 border-white border-t-transparent mx-auto mb-3"></div>
                                                        <p className="text-white">Processing...</p>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}

                                {activeTab === 'snap' && hasScanned && currentMovie && (
                                    <div className="h-full relative">
                                        <div className="absolute inset-0 bg-gradient-to-b from-gray-800 via-gray-900 to-black">
                                            {currentMovie.poster && (
                                                <img 
                                                    src={currentMovie.poster} 
                                                    alt={currentMovie.title}
                                                    className="absolute top-1/3 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-64 h-80 rounded-lg shadow-2xl object-cover"
                                                />
                                            )}
                                        </div>
                                        <div className="absolute bottom-0 left-0 right-0 px-4 pb-2">
                                            <div className="bg-gray-800 rounded-2xl p-5 relative z-10 max-h-[70vh] overflow-y-auto">
                                                <div className="flex gap-4 mb-4">
                                                    {currentMovie.poster && (
                                                        <img 
                                                            src={currentMovie.poster}
                                                            alt={currentMovie.title}
                                                            className="w-24 h-36 rounded-lg flex-shrink-0 object-cover shadow-lg"
                                                        />
                                                    )}
                                                    <div className="flex-1">
                                                        <h2 className="text-white text-2xl font-bold mb-1">{currentMovie.title}</h2>
                                                        <p className="text-gray-400 text-sm mb-2">{currentMovie.year} â€¢ {currentMovie.genre}</p>
                                                        <p className="text-gray-300 text-xs">
                                                            <span className="text-gray-400">Starring:</span> {currentMovie.cast}
                                                        </p>
                                                    </div>
                                                </div>
                                                {(() => {
                                                    const score = currentMovie.personalScore || currentMovie.imdbRating;
                                                    if (score >= 9.0) {
                                                        return (
                                                            <div className="mb-4">
                                                                <div className="inline-flex items-center bg-red-600 text-white px-3 py-1 rounded text-sm font-semibold">
                                                                    ðŸ”¥ PERFECT MATCH
                                                                </div>
                                                            </div>
                                                        );
                                                    } else if (score >= 8.5) {
                                                        return (
                                                            <div className="mb-4">
                                                                <div className="inline-flex items-center bg-orange-600 text-white px-3 py-1 rounded text-sm font-semibold">
                                                                    <ThumbsUp className="w-4 h-4 mr-1" />
                                                                    HIGHLY RECOMMENDED
                                                                </div>
                                                            </div>
                                                        );
                                                    } else if (score >= 7.5) {
                                                        return (
                                                            <div className="mb-4">
                                                                <div className="inline-flex items-center bg-blue-600 text-white px-3 py-1 rounded text-sm font-semibold">
                                                                    ðŸ‘ WORTH WATCHING
                                                                </div>
                                                            </div>
                                                        );
                                                    }
                                                    return null;
                                                })()}
                                                {currentMovie.personalScore ? (
                                                    <div className="mb-4 p-3 bg-gradient-to-r from-purple-900/30 to-blue-900/30 rounded-xl border border-purple-500/30">
                                                        <div className="flex items-center justify-between">
                                                            <div>
                                                                <div className="text-purple-300 text-xs mb-1">For You</div>
                                                                <div className="text-white text-3xl font-bold">{currentMovie.personalScore}<span className="text-gray-400 text-lg">/10</span></div>
                                                            </div>
                                                            <div className="text-purple-400">ðŸŽ¯</div>
                                                        </div>
                                                        <div className="text-purple-200 text-xs mt-2">Based on your taste profile</div>
                                                    </div>
                                                ) : ratedCount < 5 ? (
                                                    <div className="mb-4 p-3 bg-gradient-to-r from-gray-800/50 to-gray-900/50 rounded-xl border border-gray-600/30">
                                                        <div className="flex items-center gap-3">
                                                            <div className="text-gray-400">ðŸ”’</div>
                                                            <div className="flex-1">
                                                                <div className="text-gray-300 text-sm font-semibold mb-1">Unlock Personal Score</div>
                                                                <div className="text-gray-400 text-xs">Rate {remainingNeeded} more {remainingNeeded === 1 ? 'title' : 'titles'} to see your personalized recommendations</div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                ) : null}
                                                <div className="flex items-center justify-around mb-6 pb-6 border-b border-gray-700 gap-3">
                                                    {currentMovie.imdbRating && (
                                                        <div className="text-center">
                                                            <div className="text-yellow-400 text-2xl font-bold">{currentMovie.imdbRating}/10</div>
                                                            <div className="text-gray-400 text-xs">IMDb</div>
                                                        </div>
                                                    )}
                                                    {currentMovie.rottenTomatoes && (
                                                        <div className="text-center">
                                                            <div className="text-red-500 text-2xl font-bold">{currentMovie.rottenTomatoes}%</div>
                                                            <div className="text-gray-400 text-xs">Rotten ðŸ…</div>
                                                        </div>
                                                    )}
                                                    {currentMovie.metacritic && (
                                                        <div className="text-center">
                                                            <div className="text-green-500 text-2xl font-bold">{currentMovie.metacritic}/100</div>
                                                            <div className="text-gray-400 text-xs">Metacritic</div>
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="text-center mb-4">
                                                    <p className="text-white text-sm mb-2">What's your take on this title?</p>
                                                    <p className="text-white text-sm mb-3">Rate it to build your taste profile!</p>
                                                    <button onClick={handleNotNow} className="text-gray-400 text-sm hover:text-gray-300">Skip for Now</button>
                                                </div>
                                                <div className="flex gap-3">
                                                    <button
                                                        onClick={() => handleRating('up')}
                                                        className={'flex-1 py-4 rounded-xl flex items-center justify-center ' + (currentMovieRating === 'up' ? 'bg-green-500' : 'bg-gray-600')}
                                                    >
                                                        <ThumbsUp className="w-8 h-8 text-white" />
                                                    </button>
                                                    <button
                                                        onClick={() => handleRating('down')}
                                                        className={'flex-1 py-4 rounded-xl flex items-center justify-center ' + (currentMovieRating === 'down' ? 'bg-red-500' : 'bg-gray-600')}
                                                    >
                                                        <ThumbsDown className="w-8 h-8 text-white" />
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {activeTab === 'profile' && (
                                    <div className="h-full overflow-y-auto bg-black px-6">
                                        <div className="pt-12 pb-8">
                                            <h1 className="text-white text-3xl font-bold text-center">Profile & Data</h1>
                                        </div>

                                        <div className="flex flex-col items-center mb-12">
                                            <div className="relative w-48 h-48 mb-6">
                                                <svg className="w-full h-full transform -rotate-90">
                                                    <circle cx="96" cy="96" r="88" stroke="#374151" strokeWidth="12" fill="none" />
                                                    <circle cx="96" cy="96" r="88" stroke="#10b981" strokeWidth="12" fill="none" strokeDasharray={2 * Math.PI * 88} strokeDashoffset={2 * Math.PI * 88 * (1 - progressPercentage / 100)} strokeLinecap="round" className="transition-all duration-500" />
                                                </svg>
                                                <div className="absolute inset-0 flex items-center justify-center">
                                                    <span className="text-white text-5xl font-bold">{Math.round(progressPercentage)}%</span>
                                                </div>
                                            </div>
                                            <p className="text-white text-xl font-semibold">Your Taste Profile</p>
                                        </div>
                                        <div className="space-y-3 mb-8">
                                            <button className="w-full bg-gray-800 hover:bg-gray-700 text-white py-4 px-5 rounded-xl flex items-center gap-3 border border-gray-700">
                                                <Palette className="w-6 h-6" />
                                                <span className="text-lg">Edit Taste Profile</span>
                                            </button>
                                            <button
                                                onClick={async () => {
                                                    if (confirm('Are you sure you want to delete all your history? This cannot be undone.')) {
                                                        setMovieHistory({});

                                                        // Delete all movies from backend
                                                        try {
                                                            const movieIds = Object.keys(movieHistory);
                                                            await Promise.all(
                                                                movieIds.map(id =>
                                                                    fetch(`${BACKEND_URL}/api/ratings/${id}`, {
                                                                        method: 'DELETE',
                                                                        credentials: 'include'
                                                                    })
                                                                )
                                                            );
                                                            console.log('âœ… All movies deleted from backend');
                                                            alert('History deleted successfully.');
                                                        } catch (error) {
                                                            console.error('Error deleting history:', error);
                                                            alert('History deleted from UI, but backend deletion may have failed.');
                                                        }
                                                    }
                                                }}
                                                className="w-full bg-gray-800 hover:bg-gray-700 text-white py-4 px-5 rounded-xl flex items-center gap-3 border border-gray-700"
                                            >
                                                <Trash2 className="w-6 h-6 text-red-500" />
                                                <span className="text-lg">Delete Taste Profile</span>
                                            </button>
                                        </div>
                                        <div className="border-t border-gray-800 my-6"></div>
                                        <div className="pb-24">
                                            <h2 className="text-white text-xl font-bold mb-4">Settings & Account</h2>
                                            <div className="space-y-1">
                                                <button className="w-full text-white py-4 px-2 flex items-center justify-between hover:bg-gray-800 rounded-lg">
                                                    <div className="flex items-center gap-3">
                                                        <Hash className="w-5 h-5 text-gray-400" />
                                                        <span className="text-lg">Account</span>
                                                    </div>
                                                    <ChevronRight className="w-5 h-5 text-gray-400" />
                                                </button>
                                                <button className="w-full text-white py-4 px-2 flex items-center gap-3 hover:bg-gray-800 rounded-lg">
                                                    <Moon className="w-5 h-5 text-gray-400" />
                                                    <span className="text-lg">Dark Mode</span>
                                                </button>
                                                <button className="w-full text-white py-4 px-2 flex items-center justify-between hover:bg-gray-800 rounded-lg">
                                                    <div className="flex items-center gap-3">
                                                        <HelpCircle className="w-5 h-5 text-gray-400" />
                                                        <span className="text-lg">Help and Support</span>
                                                    </div>
                                                    <ChevronRight className="w-5 h-5 text-gray-400" />
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>

                            <div className="bg-black border-t border-gray-800 pt-2 safe-area-bottom">
                                <div className="flex items-center justify-around px-8 safe-area-left safe-area-right">
                                    <button onClick={() => { setActiveTab('history'); setHasScanned(false); stopCamera(); setSwipedItem(null); setSwipeOffset(0); }} className="flex flex-col items-center gap-1 py-2 px-4">
                                        <Clock className={'w-6 h-6 ' + (activeTab === 'history' ? 'text-white' : 'text-gray-500')} />
                                        <span className={'text-xs ' + (activeTab === 'history' ? 'text-white' : 'text-gray-500')}>History</span>
                                    </button>
                                    <button onClick={() => { setActiveTab('snap'); setHasScanned(false); setSwipedItem(null); setSwipeOffset(0); }} className="flex flex-col items-center gap-1 py-2 px-4">
                                        <Camera className={'w-6 h-6 ' + (activeTab === 'snap' ? 'text-white' : 'text-gray-500')} />
                                        <span className={'text-xs ' + (activeTab === 'snap' ? 'text-white' : 'text-gray-500')}>Snap</span>
                                    </button>
                                    <button onClick={() => { setActiveTab('profile'); setHasScanned(false); stopCamera(); setSwipedItem(null); setSwipeOffset(0); }} className="flex flex-col items-center gap-1 py-2 px-4">
                                        <User className={'w-6 h-6 ' + (activeTab === 'profile' ? 'text-white' : 'text-gray-500')} />
                                        <span className={'text-xs ' + (activeTab === 'profile' ? 'text-white' : 'text-gray-500')}>Profile</span>
                                    </button>
                                </div>
                                <div className="flex justify-center mt-2">
                                    <div className="w-32 h-1 bg-white rounded-full opacity-30"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<CineSenseApp />, document.getElementById('root'));
    </script>
</body>
</html>
